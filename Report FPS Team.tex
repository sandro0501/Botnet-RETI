\documentclass[a4paper]{report}
\usepackage{hyperref}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, italian]{babel}
\usepackage{lipsum} 
\usepackage{url} 
\usepackage[table,xcdraw]{xcolor}
\usepackage {amssymb}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage[export]{adjustbox}
\lstset{
	basicstyle=\ttfamily,
	mathescape
}
\usepackage{float}
\restylefloat{table}
\usepackage[normalem]{ulem}
\useunder{\uline}{\ul}{}
\maxdeadcycles=1000
\begin{document}
\author {Ferdinando D'Alessandro\\N86003933\and Pasquale Kevyn Carderopoli \\ N86003931\and Santolo Barretta\\N86003666}
\title {
	\begin{figure}[hp]
		\centerline{\includegraphics[scale=.04]{SimboloFedericoII}}
	\end{figure} Report sullo sviluppo e le prove di esecuzione di una botnet in Python }


\date{}
\maketitle

\tableofcontents

\chapter{Sviluppo della botnet}

\section{Architettura client server}

Iniziando a sviluppare la botnet la prima decisione che abbiamo preso è stata la gestione dell'architettura.
Una botnet è una rete composta da uno o più bot che inviano dati al botmaster, nel nostro caso che comunicano tramite socket TCP.\\
Abbiamo deciso che i bot sarebbero stati i client mentre il botmaster il server, questo per più ragioni:
\begin{itemize}
	\item Ci risultava la scelta più appropriata da un punto di vista ideologico: noi dovevamo avere in mano la situazione e quindi usare il server. Ci sembrava giusto che fossero i bot a contattare il server una volta reperite le informazioni e non il contrario.
	\item Anche se è stata una simulazione, in una situazione realistica sarebbe scomodo dover sapere necessariamente l'ip di tutti i bot, mentre un botmaster è probabile sia configurato su un ip statico facilmente raggiungibile da tutti i bot (Come poi è stato nella prova finale).
	\item Dato che il botmaster è uno soltanto mentre è possibile ci siano più bot, risulta più comodo far connettere più bot client a un server botmaster.
	\item Se avessimo scelto l'architettura opposta avremmo avuto il botmaster che faceva da client e avrebbe dovuto connettersi ogni volta ad un bot server diverso, ostacolando una facile estensione della rete di bot.
\end{itemize}

\section{Funzionalità implementate}
Abbiamo deciso di sviluppare il bot in modo che rispondesse in tempo reale alle richieste fatte dal botmaster, effettuate attraverso un menù che abbiamo sviluppato.\\
Per ottenere le informazioni che volevamo sul dispositivo vittima del bot abbiamo fatto uso di diverse librerie tra cui platform, os, subprocess e psutil.
Ad ogni opzione del menù quindi corrisponde un set di informazioni che il bot ci restituisce, in particolare:
\\
\begin{enumerate}
	
	\item \textbf{Informazioni sul sistema:}
	\begin{itemize}
		\item Nome e versione del sistema operativo installato;
		\item Nome dell'utente corrente;
		\item Architettura del dispositivo;
		\item Tempo di avvio del sistema.
	\end{itemize}
	
	\item \textbf{Informazioni sulla CPU:}
	\begin{itemize}
		\item Nome del modello del processore;
		\item Numero di core fisici e logici;
		\item Frequenza di CPU massima, minima e corrente;
		\item Percentuale di uso della CPU.
	\end{itemize}
	
	\item \textbf{Informazioni sul disco e le sue partizioni:}
	\begin{itemize}
		\item Nome delle partizioni;
		\item Tipo di file system;
		\item Punto di montaggio;
		\item Dimensione, spazio libero ed occupato.
	\end{itemize}
	
	\item \textbf{Informazioni sulla scheda di rete e sulle interfacce di rete:}
	\begin{itemize}
		\item Indirizzo MAC della scheda di rete;
		\item Indirizzo IP e maschera di sottorete delle interfacce.
	\end{itemize}
	
	\item \textbf{Statistiche sulla rete:}
	\begin{itemize}
		\item Numero di byte inviati e ricevuti;
		\item Numero di pacchetti inviati e ricevuti;
		\item Numero di pacchetti persi in invio e ricezione;
		\item Numero di errori in invio e ricezione.
	\end{itemize}
	
\end{enumerate}

Abbiamo poi deciso di implementare una \underline{reverse shell}, cioè inviare dei comandi affinché vengano eseguiti sulla macchina del bot client.\\
In particolare per eseguire il comando a distanza abbiamo fatto uso dei metodi \textit{os.getoutput(...)} e \textit{os.check\_output(...)} passando il comando ottenuto da input dopo aver escluso casi di comandi particolari come il cambio della directory corrente (\textit{cd}).\\
Abbiamo sfruttato la reverse shell per ottenere informazioni sulla macchina più approfondite laddove le librerie esterne non bastavano e per navigare il file system alla ricerca di file che potessero risultarci appetibili, preferendolo come approccio rispetto ad uno più diretto come il download o la scansione automatica dell'intero file system, che potrebbe diventare un processo troppo pesante e lento su alcune macchine.\\
Tuttavia senza estensioni ulteriori potevamo solamente stampare e ricavare il contenuto di file di testo, attraverso comandi come more o cat; per questo prima della seconda prova abbiamo anche aggiunto la possibilità di scaricare dei file in modo da poter gestire qualsiasi tipo di file.\\

\section{Tecniche per rendere più solido lo scambio di messaggi}
Molto del tempo di sviluppo della botnet è stato mirato al renderla il più solida possibile, data la facile tendenza a problemi di comunicazione lavorando con le socket.
Purtroppo nonostante tutte le misure di precauzione prese, il programma ha dato comunque dei problemi ma il nostro lavoro ha permesso alla situazione di ristabilirsi seppur con la perdita di qualche dato.\\
Ricordiamo che la receive nelle socket in Python prende una dimensione massima di byte da ricevere, questione che ha portato dubbi e problemi riguardanti la dimensione del buffer scelta. Infatti ci è risultato subito chiaro che, qualsiasi fosse stata la dimensione scelta, alcuni dei messaggi inviati dal bot sarebbero risultati troppo grandi. Per questo abbiamo lavorato in due modi:
\begin{enumerate}
	\item Dapprima abbiamo implementato una manovra forzata per cui nel caso in cui si fosse notato un problema di bufferizzazione, avremmo forzato il server tramite un comando a fare una receive extra, in modo da svuotare il buffer;
	\item Per la seconda prova invece abbiamo lavorato ad un'automatizzazione di questo processo, facendo sì che il client mandasse prima il numero di receive che il server avrebbe dovuto fare (Calcolato a partire dalla dimensione del messaggio chiaramente) e poi il messaggio vero e proprio, permettendo così al server di ricevere in modo adeguato il messaggio.\\
	Questo scambio di messaggi si può vedere meglio dalla scansione effettuata con Wireshark che è analizzata a fine report.
\end{enumerate}
Infine per cercare di salvare situazioni disastrose che si possono verificare in uno scenario reale e che purtroppo si sono verificate anche nelle simulazioni di prova, abbiamo manipolato client e server affinché cerchino sempre di riconnettersi non appena la connessione è persa.

\chapter{Prove di esecuzione}

\section{Prima prova}

\section{Seconda prova}

\chapter{Analisi di frammenti di comunicazione ottenuti con Wireshark}

\end{document}